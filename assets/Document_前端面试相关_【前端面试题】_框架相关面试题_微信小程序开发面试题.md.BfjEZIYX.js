import{_ as e,c as p,l as s,a,t as l,a5 as n,o}from"./chunks/framework.DVTrgelf.js";const i="/FrontEndInterviewQuestion/assets/image-20240315210705227.DzsA4m_U.png",r="/FrontEndInterviewQuestion/assets/image-20240315210753536.BPR0m_AP.png",t="/FrontEndInterviewQuestion/assets/image-20240315211232258.qbz3XnlU.png",c="/FrontEndInterviewQuestion/assets/image-20240315211341522.wNwaik3h.png",u="/FrontEndInterviewQuestion/assets/image-20240315211358607.BhIf9_DO.png",d="/FrontEndInterviewQuestion/assets/image-20240315211500665.BuhU4Vvm.png",B="/FrontEndInterviewQuestion/assets/image-20240315211538280.DgLrOy9l.png",y="/FrontEndInterviewQuestion/assets/image-20240315211834102.CdV2JZdg.png",b="/FrontEndInterviewQuestion/assets/image-20240315212236596.DWCmE-6_.png",h="/FrontEndInterviewQuestion/assets/image-20240315212312132.CQXJwJjB.png",m="/FrontEndInterviewQuestion/assets/image-20240315212334750.CPKi3bEb.png",F="/FrontEndInterviewQuestion/assets/image-20240315212436234.YLJ8ms-o.png",X=JSON.parse('{"title":"微信小程序开发面试题","description":"","frontmatter":{},"headers":[],"relativePath":"Document/前端面试相关/【前端面试题】/框架相关面试题/微信小程序开发面试题.md","filePath":"Document/前端面试相关/【前端面试题】/框架相关面试题/微信小程序开发面试题.md","lastUpdated":1716655893000}'),A={name:"Document/前端面试相关/【前端面试题】/框架相关面试题/微信小程序开发面试题.md"},g=n('<h1 id="微信小程序开发面试题" tabindex="-1">微信小程序开发面试题 <a class="header-anchor" href="#微信小程序开发面试题" aria-label="Permalink to &quot;微信小程序开发面试题&quot;">​</a></h1><h2 id="微信小程序的文件类型" tabindex="-1">微信小程序的文件类型 <a class="header-anchor" href="#微信小程序的文件类型" aria-label="Permalink to &quot;微信小程序的文件类型&quot;">​</a></h2><ul><li><code>wxml</code>：模板文件，用于描述页面的结构。</li><li><code>wxss</code>：样式文件，用于描述页面的样式。</li><li><code>js</code>：脚本逻辑文件，处理页面的业务逻辑。</li><li><code>json</code>：配置文件，用于配置页面、组件等信息。</li></ul><h2 id="wxml-与标准-html-的异同" tabindex="-1">WXML 与标准 HTML 的异同 <a class="header-anchor" href="#wxml-与标准-html-的异同" aria-label="Permalink to &quot;WXML 与标准 HTML 的异同&quot;">​</a></h2>',4),C=s("li",null,"相同点：都用于描述页面的结构，由标签和属性构成。",-1),_=s("code",null,"wx:if",-1),q=n('<h2 id="wxss-与-css-的异同" tabindex="-1">WXSS 与 CSS 的异同 <a class="header-anchor" href="#wxss-与-css-的异同" aria-label="Permalink to &quot;WXSS 与 CSS 的异同&quot;">​</a></h2><ul><li>相同点：都用于描述页面的样式。</li><li>不同点：WXSS 支持 rpx 单位、局部样式和全局样式。</li></ul><h2 id="微信小程序的数据请求封装" tabindex="-1">微信小程序的数据请求封装 <a class="header-anchor" href="#微信小程序的数据请求封装" aria-label="Permalink to &quot;微信小程序的数据请求封装&quot;">​</a></h2><ul><li>可在根目录下创建 <code>util</code> 目录，封装请求方法。</li><li>使用 <code>wx.request</code> 发送请求，处理成功和失败回调。</li></ul><h2 id="_1、微信小程序有几个文件" tabindex="-1">1、微信小程序有几个文件 <a class="header-anchor" href="#_1、微信小程序有几个文件" aria-label="Permalink to &quot;1、微信小程序有几个文件&quot;">​</a></h2><ul><li>WXSS (WeiXin Style Sheets) 是一套样式语⾔，用于描述 WXML 的组件样式， js 逻辑处理，网络请求 json 小程序设置，如页面注册，页面标题及 tabBar 。</li><li>app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景⾊，配置导航条样式，配置默认标题。</li><li>app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。</li><li>app.wxss 配置全局 css</li></ul><h2 id="_2、微信小程序怎样跟事件传值" tabindex="-1">2、微信小程序怎样跟事件传值 <a class="header-anchor" href="#_2、微信小程序怎样跟事件传值" aria-label="Permalink to &quot;2、微信小程序怎样跟事件传值&quot;">​</a></h2><p>给 HTML 元素添加 <code>data-*</code> 属性来传递我们需要的值，然后通过 <code>e.currentTarget.dataset</code> 或 <code>onload</code> 的 <code>param</code> 参数获取。但 data -名称不能有大写字⺟和不可以存放对象。</p><h2 id="_3、小程序的-wxss-和-css-有哪些不一样的地方" tabindex="-1">3、小程序的 wxss 和 css 有哪些不一样的地方？ <a class="header-anchor" href="#_3、小程序的-wxss-和-css-有哪些不一样的地方" aria-label="Permalink to &quot;3、小程序的 wxss 和 css 有哪些不一样的地方？&quot;">​</a></h2><p>wxss 的图片引入需使用外链地址</p><p>没有 Body ；样式可直接使用 import 导入</p><h2 id="_4、小程序关联微信公众号如何确定用户的唯一性" tabindex="-1">4、小程序关联微信公众号如何确定用户的唯一性 <a class="header-anchor" href="#_4、小程序关联微信公众号如何确定用户的唯一性" aria-label="Permalink to &quot;4、小程序关联微信公众号如何确定用户的唯一性&quot;">​</a></h2><p>使用 wx.getUserInfo 方法 withCredentials 为 true 时 可获取 encryptedData ，里面有 union_id 。后端需要进行对称解密。</p><h2 id="_5、微信小程序与-vue-区别" tabindex="-1">5、微信小程序与 vue 区别 <a class="header-anchor" href="#_5、微信小程序与-vue-区别" aria-label="Permalink to &quot;5、微信小程序与 vue 区别&quot;">​</a></h2>',14),x=s("li",null,"生命周期不一样，微信小程序生命周期比较简单",-1),k=s("li",null,"显示与隐藏元素， vue 中，使用 v-if 和 v-show 控制元素的显示和隐藏，小程序中，使用 wx-if 和 hidden 控制元素的显示和隐藏",-1),E=s("li",null,"事件处理不同，小程序中，全用 bindtap(bind+event) ，或者 catchtap(catch+event) 绑定事件, vue： 使用 v-on:event 绑定事件，或者使用@event 绑定事件",-1),w=s("li",null,"数据双向绑定也不也不一样在 vue 中,只需要再表单元素上加上 v-model ,然后再绑定 data 中对应的一个值，当表单元素内容发生变化时， data 中对应的值也会相应改变，这是 vue 非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 data 中声明的变量。",-1),f=n(`<h2 id="_1-登录" tabindex="-1">1 登录 <a class="header-anchor" href="#_1-登录" aria-label="Permalink to &quot;1 登录&quot;">​</a></h2><h3 id="unionid-和-openid" tabindex="-1">unionid 和 openid <a class="header-anchor" href="#unionid-和-openid" aria-label="Permalink to &quot;unionid 和 openid&quot;">​</a></h3><p>了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用 户标识：</p><ol><li>OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。</li><li>UnionId 是一个用户对于同主体微信小程序／公众号／ APP 的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过 UnionId ，实现多个小程序、公众号、甚⾄ APP 之间的数据互通了。</li></ol><h3 id="关键-api" tabindex="-1">关键 Api <a class="header-anchor" href="#关键-api" aria-label="Permalink to &quot;关键 Api&quot;">​</a></h3><ul><li>wx.login 官方提供的登录能⼒</li><li>wx.checkSession 校验用户当前的 session_key 是否有效</li><li>wx.authorize 提前向用户发起授权请求</li><li>wx.getUserInfo 获取用户基本信息</li></ul><h3 id="登录流程设计" tabindex="-1">登录流程设计 <a class="header-anchor" href="#登录流程设计" aria-label="Permalink to &quot;登录流程设计&quot;">​</a></h3><h4 id="利用现有登录体系" tabindex="-1">利用现有登录体系 <a class="header-anchor" href="#利用现有登录体系" aria-label="Permalink to &quot;利用现有登录体系&quot;">​</a></h4><p>直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输 入页面，便可以简便的实现登录，只需要保持良好的用户体验即可</p><h4 id="利用-openid-创建用户体系" tabindex="-1">利用 OpenId 创建用户体系 <a class="header-anchor" href="#利用-openid-创建用户体系" aria-label="Permalink to &quot;利用 OpenId 创建用户体系&quot;">​</a></h4><p>OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实 现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最 低，可以实现静默登录。具体步骤如下：</p><ul><li><p>小程序客户端通过 wx.login 获取 code</p></li><li><p>传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录状态</p></li><li><p>小程序客户端缓存 （通过 storage ）自定义登录态（ token ），后续调用接口时携带该登录态作为用户身份标识即可</p></li><li><h4 id="利用-unionid-创建用户体系" tabindex="-1">利用 Unionid 创建用户体系 <a class="header-anchor" href="#利用-unionid-创建用户体系" aria-label="Permalink to &quot;利用 Unionid 创建用户体系&quot;">​</a></h4></li></ul><p>如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 unionid 呢，有以下两种方式：</p><ul><li>如果户关注了某个相同主体公众号，或曾经在某个相同主体 App 、公众号上进行过微信登录授权，通过 wx.login 可以直接获取 到 unionid</li><li>结合 wx.getUserInfo 和 <code>&lt;button open-type=&quot;getUserInfo&quot;&gt;&lt;button/&gt;</code> 这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践 <ul><li>调用 wx.login 获取 code ，然后从微信后端换取到 session_key ，用于解密 getUserInfo 返回的敏感数据</li><li>使用 wx.getSetting 获取用户的授权情况 <ul><li>如果用户已经授权，直接调用 API wx.getUserInfo 获取用户最新的信息；</li><li>用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息</li></ul></li><li>获取到用户数据后可以进行展示或者发送给自己的后端。</li></ul></li></ul><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><p>需要获取 unionid 形式的登录体系，在以前（18 年 4 ⽉之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸⼼理，以防造成小程序不过审等情况</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#61AFEF;">wx.login(获取code</span><span style="color:#ABB2BF;">) ===&gt; wx.getUserInfo(</span><span style="color:#61AFEF;">用户授权</span><span style="color:#ABB2BF;">) ===&gt; 获取 unionid</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>因为小程序不存在 cookie 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间</li><li>值得一提的是如果需要支持⻛控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如 platform ， channel ， deviceParam 等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的统。</li><li>openid ， unionid 不要在接口中明文传输，这是一种危险的行为，同时也很不专业</li></ul><h2 id="_2-图片导出" tabindex="-1">2 图片导出 <a class="header-anchor" href="#_2-图片导出" aria-label="Permalink to &quot;2 图片导出&quot;">​</a></h2><p>这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。</p><h3 id="基本原理" tabindex="-1">基本原理 <a class="header-anchor" href="#基本原理" aria-label="Permalink to &quot;基本原理&quot;">​</a></h3><ul><li>借助 canvas 元素，将需要导出的样式首先在 canvas 画布上绘制出来 （ api 基本和 h5 保持一致，但有轻微差异，使用时注意即可</li><li>借助微信提供的 canvasToTempFilePath 导出图片，最后再使用 saveImageToPhotosAlbum （需要授权）保存图片到本地</li></ul><h3 id="如何优雅实现" tabindex="-1">如何优雅实现 <a class="header-anchor" href="#如何优雅实现" aria-label="Permalink to &quot;如何优雅实现&quot;">​</a></h3><ul><li>绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个 type 参数来指定绘制类型，传入的一个是样式数组，实现绘制。</li><li>结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">class</span><span style="color:#E5C07B;"> CanvasKit</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">    constructor</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#61AFEF;">    drawImg</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">option</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {}) {</span></span>
<span class="line"><span style="color:#ABB2BF;">        ...</span></span>
<span class="line"><span style="color:#C678DD;">        return</span><span style="color:#E5C07B;"> this</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#61AFEF;">    drawRect</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">option</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {}) {</span></span>
<span class="line"><span style="color:#C678DD;">    	return</span><span style="color:#E5C07B;"> this</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#61AFEF;">    drawText</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">option</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {}) {</span></span>
<span class="line"><span style="color:#ABB2BF;">        ...</span></span>
<span class="line"><span style="color:#C678DD;">        return</span><span style="color:#E5C07B;"> this</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    static</span><span style="color:#61AFEF;"> exportImg</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">option</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {}) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    	...</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#E06C75;"> drawer</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> CanvasKit</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;canvasId&#39;</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">drawImg</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">styleObj1</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">drawText</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">styleOb</span></span>
<span class="line"><span style="color:#E5C07B;"> drawer</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">exportImg</span><span style="color:#ABB2BF;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="注意事项-1" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项-1" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>小程序中无法绘制网络图片到 canvas 上，需要通过 downLoadFile 先下载图片到本地临时文件才可以绘制</li><li>通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（ 32 可见字符）限制，可以借助服务端生成 短链接 的方式来解决</li></ul><h2 id="_3-数据统计" tabindex="-1">3 数据统计 <a class="header-anchor" href="#_3-数据统计" aria-label="Permalink to &quot;3 数据统计&quot;">​</a></h2><p>数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。</p><p>小程序采取的曝光，点击数据埋点其实和 h5 原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会⼲扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点</p><h3 id="设计一个埋点-sdk" tabindex="-1">设计一个埋点 sdk <a class="header-anchor" href="#设计一个埋点-sdk" aria-label="Permalink to &quot;设计一个埋点 sdk&quot;">​</a></h3><p>小程序的代码结构是，每一个 Page 中都有一个 Page 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对 Page 进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不⼲扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 代码仅供理解思路</span></span>
<span class="line"><span style="color:#61AFEF;">page</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> function</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">params</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;"> let</span><span style="color:#E06C75;"> keys</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> params</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">keys</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;"> keys</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">forEach</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">v</span><span style="color:#C678DD;"> =&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">     if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">v</span><span style="color:#56B6C2;"> ===</span><span style="color:#98C379;"> &#39;onLoad&#39;</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#E06C75;">     params</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">v</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> function</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">options</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#61AFEF;">         stat</span><span style="color:#ABB2BF;">() </span><span style="color:#7F848E;font-style:italic;">// 曝光埋点代码</span></span>
<span class="line"><span style="color:#E06C75;">         params</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">v</span><span style="color:#ABB2BF;">].</span><span style="color:#61AFEF;">call</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">options</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">     }</span></span>
<span class="line"><span style="color:#ABB2BF;"> } </span><span style="color:#C678DD;">else</span><span style="color:#C678DD;"> if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">v</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">includes</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;click&#39;</span><span style="color:#ABB2BF;">)) {</span></span>
<span class="line"><span style="color:#E06C75;">     params</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">v</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> funciton</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">event</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;">         let</span><span style="color:#E06C75;"> data</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> event</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">dataset</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">config</span></span>
<span class="line"><span style="color:#61AFEF;">         stat</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">data</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">// 点击埋点</span></span>
<span class="line"><span style="color:#E06C75;">         param</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">v</span><span style="color:#ABB2BF;">].</span><span style="color:#61AFEF;">call</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">     }</span></span>
<span class="line"><span style="color:#ABB2BF;">     }</span></span>
<span class="line"><span style="color:#ABB2BF;"> })</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场 景。</p><h3 id="分析接口" tabindex="-1">分析接口 <a class="header-anchor" href="#分析接口" aria-label="Permalink to &quot;分析接口&quot;">​</a></h3><p>对于特殊的一些业务，我们可以采取 接口埋点，什么叫接口埋点呢？很多情况下，我们有的 api 并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端⽇志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。</p><h3 id="微信自定义数据分析" tabindex="-1">微信自定义数据分析 <a class="header-anchor" href="#微信自定义数据分析" aria-label="Permalink to &quot;微信自定义数据分析&quot;">​</a></h3><p>微信本身提供的数据分析能⼒，微信本身提供了常规分析和自定义分析两种数 据分析方式，在小程序后台配置即可。借助小程序数据助手这款小程序可以很 方便的查看</p><h2 id="_4-工程化" tabindex="-1">4 工程化 <a class="header-anchor" href="#_4-工程化" aria-label="Permalink to &quot;4 工程化&quot;">​</a></h2><h3 id="工程化做什么" tabindex="-1">工程化做什么 <a class="header-anchor" href="#工程化做什么" aria-label="Permalink to &quot;工程化做什么&quot;">​</a></h3><p>目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决：</p><ul><li>不支持 css 预编译器,作为一种主流的 css 解决方案，不论是 less , sass , stylus 都可以提升 css 效率</li><li>不支持引入 npm 包 （这一条，从微信公开课中听闻，微信准备支持）</li><li>不支持 ES7 等后续的 js 特性，好用的 async await 等特性都无法使用</li><li>不支持引入外部字体文件，只支持 base64</li><li>没有 eslint 等代码检查工具</li></ul><h3 id="方案选型" tabindex="-1">方案选型 <a class="header-anchor" href="#方案选型" aria-label="Permalink to &quot;方案选型&quot;">​</a></h3><p>对于目前常用的工程化方案， webpack ， rollup ， parcel 等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷⻉这些处理，对于这些需求，我们想到基于流的 gulp 非常的适合处理，并且相对于 webpack 配置多页应用更加简单。所以小程序工程化方案推荐使用 gulp</p><h3 id="具体开发思路" tabindex="-1">具体开发思路 <a class="header-anchor" href="#具体开发思路" aria-label="Permalink to &quot;具体开发思路&quot;">​</a></h3><p>通过 gulp 的 task 实现：</p><ul><li>实时编译 less 文件⾄相应目录</li><li>引入支持 async ， await 的运行时文件</li><li>编译字体文件为 base64 并生成相应 css 文件，方便使用</li><li>依赖分析哪些地方引用了 npm 包，将 npm 包打成一个文件，拷⻉⾄相应目录</li><li>检查代码规范</li></ul><h2 id="小程序架构" tabindex="-1">小程序架构 <a class="header-anchor" href="#小程序架构" aria-label="Permalink to &quot;小程序架构&quot;">​</a></h2><p><img src="`+i+'" alt="image-20240315210705227"></p><p>微信小程序的框架包含两部分 View 视图层、 App Service 逻辑层。</p><p>View 层用来渲染页面结构， AppService 层用来逻辑处理、数据请求、接 口调用。</p><p>它们在两个线程里运行。</p><p>视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理</p><h3 id="小程序的渲染机制" tabindex="-1">小程序的渲染机制 <a class="header-anchor" href="#小程序的渲染机制" aria-label="Permalink to &quot;小程序的渲染机制&quot;">​</a></h3><p><img src="'+r+`" alt="image-20240315210753536"></p><ul><li><strong>视图层</strong>使用 WebView 渲染， iOS 中使用自带 WKWebView ，在 Android 使用腾讯的 x5 内核（基于 Blink ）运行。</li><li><strong>逻辑层</strong>使用在 iOS 中使用自带的 JSCore 运行，在 Android 中使用腾讯的 x5 内核（基于 Blink ）运行。</li><li><strong>开发工具</strong>使用 nw.js 同时提供了视图层和逻辑层的运行环境。</li></ul><h2 id="_6-wxml-wxss" tabindex="-1">6 WXML &amp;&amp; WXSS <a class="header-anchor" href="#_6-wxml-wxss" aria-label="Permalink to &quot;6 WXML &amp;&amp; WXSS&quot;">​</a></h2><h3 id="wxml" tabindex="-1">WXML <a class="header-anchor" href="#wxml" aria-label="Permalink to &quot;WXML&quot;">​</a></h3><ul><li>支持数据绑定</li><li>支持逻辑算术、运算</li><li>支持模板、引用</li><li>支持添加事件（ bindtap ）</li><li>Wxml 编译器： Wcc 把 Wxml 文件 转为 JS</li><li>执行方式： Wcc index.wxml</li><li>使用 Virtual DOM ，进行局部更新</li></ul><h3 id="wxss" tabindex="-1">WXSS <a class="header-anchor" href="#wxss" aria-label="Permalink to &quot;WXSS&quot;">​</a></h3><ul><li>wxss 编译器： wcsc 把 wxss 文件转化为 js</li><li>执行方式： wcsc index.wxss</li></ul><h3 id="尺寸单位-rpx" tabindex="-1">尺⼨单位 rpx <a class="header-anchor" href="#尺寸单位-rpx" aria-label="Permalink to &quot;尺⼨单位 rpx&quot;">​</a></h3><p>rpx（responsive pixel ）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx 。</p><p>公式：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> dsWidth</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 750</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">export</span><span style="color:#C678DD;"> const</span><span style="color:#61AFEF;"> screenHeightOfRpx</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> function</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;"> (</span><span style="color:#D19A66;">750</span><span style="color:#56B6C2;"> /</span><span style="color:#E5C07B;"> env</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">screenWidth</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">*</span><span style="color:#E5C07B;"> env</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">screenHeight</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"><span style="color:#C678DD;">export</span><span style="color:#C678DD;"> const</span><span style="color:#61AFEF;"> rpxToPx</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">rpx</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">env</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">screenWidth</span><span style="color:#56B6C2;"> /</span><span style="color:#D19A66;"> 750</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">*</span><span style="color:#E06C75;"> rpx</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"><span style="color:#C678DD;">export</span><span style="color:#C678DD;"> const</span><span style="color:#61AFEF;"> pxToRpx</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> function</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">px</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;"> (</span><span style="color:#D19A66;">750</span><span style="color:#56B6C2;"> /</span><span style="color:#E5C07B;"> env</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">screenWidth</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">*</span><span style="color:#E06C75;"> px</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="样式导入" tabindex="-1">样式导入 <a class="header-anchor" href="#样式导入" aria-label="Permalink to &quot;样式导入&quot;">​</a></h3><p>使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束</p><h3 id="内联样式" tabindex="-1">内联样式 <a class="header-anchor" href="#内联样式" aria-label="Permalink to &quot;内联样式&quot;">​</a></h3><p>静态的样式统一写到 class 中。 style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度</p><h3 id="全局样式与局部样式" tabindex="-1">全局样式与局部样式 <a class="header-anchor" href="#全局样式与局部样式" aria-label="Permalink to &quot;全局样式与局部样式&quot;">​</a></h3><p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器</p><h2 id="_7-小程序的问题" tabindex="-1">7 小程序的问题 <a class="header-anchor" href="#_7-小程序的问题" aria-label="Permalink to &quot;7 小程序的问题&quot;">​</a></h2><ul><li>小程序仍然使用 WebView 渲染，并非原生渲染。（部分原生）</li><li>服务端接口返回的头无法执行，比如： Set-Cookie 。</li><li>依赖浏览器环境的 JS 库不能使用。</li><li>不能使用 npm ，但是可以自搭构建工具或者使用 mpvue 。（未来官方有计划支持）</li><li>不能使用 ES7 ，可以自己用 babel+webpack 自搭或者使用 mpvue 。</li><li>不支持使用自己的字体（未来官方计划支持）。</li><li>可以用 base64 的方式来使用 iconfont 。</li><li>小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用 B 接口）。</li><li>获取二维码/小程序接口的限制</li><li>程序推送只能使用“服务通知” 而且需要用户主动触发提交 formId ，formId 只有 7 天有效期。（现在的做法是在每个页面都放入 form 并且隐藏以此获取更多的 formId 。后端使用原则为：优先使用有效期最短的）</li><li>小程序大小限制 2M，分包总计不超过 8M</li><li>转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽）</li><li>拿到相同的 unionId 必须绑在同一个开放平台下。开放平台绑定限制： <ul><li>50 个移动应用</li><li>10 个网站</li><li>50 个同主体公众号</li><li>5 个不同主体公众号</li><li>50 个同主体小程序</li><li>5 个不同主体小程序</li></ul></li><li>公众号关联小程序： <ul><li>所有公众号都可以关联小程序。</li><li>一个公众号可关联 10 个同主体的小程序，3 个不同主体的小程序。</li><li>一个小程序可关联 500 个公众号。</li><li>公众号一个⽉可新增关联小程序 13 次，小程序一个⽉可新增关联 500 次。</li></ul></li><li>一个公众号关联的 10 个同主体小程序和 3 个非同主体小程序可以互相跳转</li><li>品牌搜索不支持⾦融、医疗</li><li>小程序授权需要用户主动点击</li><li>小程序不提供测试 access_token</li><li>安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败</li><li>开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了 wx.checkSession ，并且在 session_key 有效期内，授权获取用户信息也会得到新的 session_key</li></ul><h2 id="_8-授权获取用户信息流程" tabindex="-1">8 授权获取用户信息流程 <a class="header-anchor" href="#_8-授权获取用户信息流程" aria-label="Permalink to &quot;8 授权获取用户信息流程&quot;">​</a></h2><p><img src="`+t+'" alt="image-20240315211232258"></p><ul><li>session_key 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，session_key 有效期越长</li><li>在调用 wx.login 时会直接更新 session_key ，导致旧 session_key 失效</li><li>小程序内先调用 wx.checkSession 检查登录态，并保证没有过期的 session_key 不会被更新，再调用 wx.login 获取 code 。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 code 传给后端服务。后端通过 code 拿到 session_key 并解密数据，将解密后的用户信息返回给小程序</li></ul><h3 id="面试题-先授权获取用户信息再-login-会发生什么" tabindex="-1">面试题：先授权获取用户信息再 login 会发生什么？ <a class="header-anchor" href="#面试题-先授权获取用户信息再-login-会发生什么" aria-label="Permalink to &quot;面试题：先授权获取用户信息再 login 会发生什么？&quot;">​</a></h3><p><img src="'+c+'" alt="image-20240315211341522"></p><p><img src="'+u+'" alt="image-20240315211358607"></p><ul><li>用户授权时，开放平台使用旧的 session_key 对用户信息进行加密。调用 wx.login 重新登录，会刷新 session_key ，这时后端服务从开放平台获取到新 session_key ，但是无法对⽼ session_key 加密过的数据解密，用户信息获取失败</li><li>在用户信息授权之前先调用 wx.checkSession 呢？ wx.checkSession 检查登录态，并且保证 wx.login 不会刷新 session_key ，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 session_key 过期，则 wx.login 必定会重新生成 session_key ，从而再一次导致用户信息解密失败</li></ul><h2 id="_9-性能优化" tabindex="-1">9 性能优化 <a class="header-anchor" href="#_9-性能优化" aria-label="Permalink to &quot;9 性能优化&quot;">​</a></h2><p>我们知道 view 部分是运行在 webview 上的，所以前端领域的大多数优化方 式都有用加载优化</p><p>小程序的启动加载流程</p><p><img src="'+d+'" alt="image-20240315211500665"></p><p>代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载 速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码 包的大小。</p><p>小程序加载的三个阶段的表示</p><p><img src="'+B+'" alt="image-20240315211538280"></p><h3 id="优化方式" tabindex="-1">优化方式 <a class="header-anchor" href="#优化方式" aria-label="Permalink to &quot;优化方式&quot;">​</a></h3><ul><li>代码压缩</li><li>及时清理无用代码和资源文件。</li><li>减少代码包中的图片等资源文件的大小和数量。</li><li>分包加载。</li></ul><h3 id="首屏加载的体验优化建议" tabindex="-1">首屏加载的体验优化建议 <a class="header-anchor" href="#首屏加载的体验优化建议" aria-label="Permalink to &quot;首屏加载的体验优化建议&quot;">​</a></h3><ul><li>提前请求: 异步数据请求不需要等待页面渲染完成。</li><li>利用缓存: 利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。</li><li>避免白屏：先展示页面⻣架页和基础内容。</li><li>及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程无响应</li></ul><h4 id="使用分包加载优化" tabindex="-1">使用分包加载优化 <a class="header-anchor" href="#使用分包加载优化" aria-label="Permalink to &quot;使用分包加载优化&quot;">​</a></h4><p><img src="'+y+`" alt="image-20240315211834102"></p><p>在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/ TabBar 页面，以及一些所有分包都需用到公共资源/ JS 脚本，而分包则是根据开发者的配置进行划分</p><p>在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。</p><h5 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li>对开发者而⾔，能使小程序有更大的代码体积，承载更多的功能与服务</li><li>对用户而⾔，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能</li></ul><h4 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h4><ul><li>整个小程序所有分包大小不超过 8M</li><li>单个分包/主包大小不能超过 2M</li><li>原生分包加载的配置 假设支持分包的小程序目录结构如下</li></ul><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#61AFEF;">├──</span><span style="color:#98C379;"> app.js</span></span>
<span class="line"><span style="color:#61AFEF;">├──</span><span style="color:#98C379;"> app.json</span></span>
<span class="line"><span style="color:#61AFEF;">├──</span><span style="color:#98C379;"> app.wxss</span></span>
<span class="line"><span style="color:#61AFEF;">├──</span><span style="color:#98C379;"> packageA</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> └──</span><span style="color:#98C379;"> pages</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> ├──</span><span style="color:#98C379;"> cat</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> └──</span><span style="color:#98C379;"> dog</span></span>
<span class="line"><span style="color:#61AFEF;">├──</span><span style="color:#98C379;"> packageB</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> └──</span><span style="color:#98C379;"> pages</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> ├──</span><span style="color:#98C379;"> apple</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> └──</span><span style="color:#98C379;"> banana</span></span>
<span class="line"><span style="color:#61AFEF;">├──</span><span style="color:#98C379;"> pages</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> ├──</span><span style="color:#98C379;"> index</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;"> └──</span><span style="color:#98C379;"> logs</span></span>
<span class="line"><span style="color:#61AFEF;">└──</span><span style="color:#98C379;"> utils</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>开发者通过在 app.json subPackages 字段声明项目分包结构</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages&quot;</span><span style="color:#ABB2BF;">:[</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages/index&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages/logs&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;"> ],</span></span>
<span class="line"><span style="color:#98C379;"> &quot;subPackages&quot;</span><span style="color:#ABB2BF;">: [</span></span>
<span class="line"><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#98C379;"> &quot;root&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;packageA&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages&quot;</span><span style="color:#ABB2BF;">: [</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages/cat&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages/dog&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;"> ]</span></span>
<span class="line"><span style="color:#ABB2BF;"> }, {</span></span>
<span class="line"><span style="color:#98C379;"> &quot;root&quot;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;packageB&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages&quot;</span><span style="color:#ABB2BF;">: [</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages/apple&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;"> &quot;pages/banana&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;"> ]</span></span>
<span class="line"><span style="color:#ABB2BF;"> }</span></span>
<span class="line"><span style="color:#ABB2BF;"> ]</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="分包原则" tabindex="-1">分包原则 <a class="header-anchor" href="#分包原则" aria-label="Permalink to &quot;分包原则&quot;">​</a></h4><ul><li>声明 subPackages 后，将按 subPackages 配置路径进行打包， subPackages 配置路径外的目录将被打包到 app （主包） 中</li><li>app （主包）也可以有自己的 pages （即最外层的 pages 字段</li><li>subPackage 的根目录不能是另外一个 subPackage 内的子目录</li><li>首页的 TAB 页面必须在 app （主包）内</li></ul><h4 id="引用原则" tabindex="-1">引用原则 <a class="header-anchor" href="#引用原则" aria-label="Permalink to &quot;引用原则&quot;">​</a></h4><ul><li>packageA 无法 require packageB JS 文件，但可以 require app 、自己 package 内的 JS 文件</li><li>packageA 无法 import packageB 的 template ，但可以 require app 、自己 package 内的 template</li><li>packageA 无法使用 packageB 的资源，但可以使用 app 、自己 package\` 内的资源</li></ul><h4 id="分包预加载" tabindex="-1">分包预加载 <a class="header-anchor" href="#分包预加载" aria-label="Permalink to &quot;分包预加载&quot;">​</a></h4><p><img src="`+b+'" alt="image-20240315212236596"></p><p><img src="'+h+'" alt="image-20240315212312132"></p><p>渲染性能优化</p><p><img src="'+m+'" alt="image-20240315212334750"></p><ul><li>每次 setData 的调用都是一次进程间通信过程，通信开销与 setData 的数据量正相关。</li><li>setData 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。</li><li>setData 是小程序开发使用最频繁，也是最容易引发性能问题的</li></ul><h5 id="避免不当使用-setdata" tabindex="-1">避免不当使用 setData <a class="header-anchor" href="#避免不当使用-setdata" aria-label="Permalink to &quot;避免不当使用 setData&quot;">​</a></h5><ul><li>使用 data 在方法间共享数据，可能增加 setData 传输的数据量。。 data 应仅包括与页面渲染相关的数据。</li><li>使用 setData 传输大量数据，通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。仅传输页面中发生变化的数据，使用 setData 的特殊 key 实现局部更新。</li><li>短时间内频繁调用 setData ，操作卡顿，交互延迟，阻塞通信，页面渲染延迟。避免不必要的 setData ，对连续的 setData 调用进行合并。</li><li>在后台页面进行 setData ，抢占前台页面的渲染资源。页面切入后台后的 setData 调用，延迟到页面重新展示时执行。</li></ul><p><img src="'+F+'" alt="image-20240315212436234"></p><h5 id="避免不当使用-onpagescroll" tabindex="-1">避免不当使用 onPageScroll <a class="header-anchor" href="#避免不当使用-onpagescroll" aria-label="Permalink to &quot;避免不当使用 onPageScroll&quot;">​</a></h5><ul><li>只在有必要的时候监听 pageScroll 事件。不监听，则不会派发。</li><li>避免在 onPageScroll 中执行复杂逻辑</li><li>避免在 onPageScroll 中频繁调用 setData</li><li>避免滑动时频繁查询节点信息（ SelectQuery ）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（ inersectionObserver ）替代</li></ul><h5 id="使用自定义组件" tabindex="-1">使用自定义组件 <a class="header-anchor" href="#使用自定义组件" aria-label="Permalink to &quot;使用自定义组件&quot;">​</a></h5><p>在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其 他部分内容复杂性影响</p>',119);function v(D,P,S,I,T,W){return o(),p("div",null,[g,s("ul",null,[C,s("li",null,[a("不同点：WXML 标签更少，有一些特有属性如 "),_,a(" 和 "),s("code",null,l(),1),a(" 表达式。")])]),q,s("ul",null,[x,s("li",null,"数据绑定也不同，微信小程序数据绑定需要使用 "+l()+" ， vue 直接 : 就可以",1),k,E,w]),f])}const V=e(A,[["render",v]]);export{X as __pageData,V as default};
